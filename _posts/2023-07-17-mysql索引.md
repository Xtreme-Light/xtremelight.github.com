---
title: mysql索引
date: 2023-07-17 19:00:00+0800
categories: [IT, mysql]
tags: [mysql, 索引]    
---

推荐阅读[小林图解](https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB)，这里讲的是mysql的索引

这里我直接记录一下我获得到的提炼知识点，作为面试和笔记使用。

## 索引

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

![img](/assets/image/2023-07-17-mysql索引/索引分类.drawio.png)

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

Innodb根据索引类型不同分为聚集和二级索引。

他们区别在于，聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。

表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。



## B+ 树

相比较于B树，主要的点为

* B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O。所以效率非常高
* 删除节点时，B+树的变化范围更小，也就是说B+的插入和删除效率更高
* B+ 树所有叶子节点间还有一个双向链表进行连接，对范围查询非常有帮助

相比较于hash索引，B+可以很好的应对范围查询，hash很好的做命中，但是对于范围查询有些捉襟见肘。

相较于普通的二叉树，B家族的树解决了树的高度增长问题，是自平衡树。二叉树只有两个节点，树的高度过高且可能退化成链表。





## 索引的优化

> explain的输出结果Extra字段为 `Using index`，则 **索引覆盖**

索引的作用和书的目录是一样的，都是为了快速定位数据。

二级索引的叶子节点存储的是数据的主键ID，当获取的数据并不在索引时，需要在获取到数据ID后走主键索引获取到对应的数据，整体上用了两颗索引树。此时就是 **回表** 。比如`select id,name from user where name='shenjian';`如果name建立了索引，而id和name都能通过这个索引树获取到，因为name的索引树的叶子节点存储的就是主键ID，则不需要回表，但是如果 `select * from user where name='shenjian';` 显然其他额外字段的内容只能通过id获取到这行的数据获取到，必须要回表查询。

## 前缀索引

如果字段是大字符串，可以将字符创的前部分字符做索引

好处：

1. 减少索引字段大小
2. 提高索引的查询速度

坏处：

1. order 不要无法使用前缀索引
2. 无法将前缀引用作为覆盖索引

### 覆盖索引优化

query查询的所有字段都有索引，这样就不需要二次查询聚簇索引，从而不需要回表。

这也就是索引覆盖。

这也就意味着不要随便使用select * 转而使用select 具体的字段，同时保证这些字段会被索引覆盖。

### 主键自增

因为聚簇索引必然存在，那么当主键递增时，对于B+都是追加操作，而不需要移动树中的其他数据，效率非常高。

使用飞自增主键，那么会导致页分裂，同时造成大量的内存碎片，导致索引结构不紧凑，印象查询效率。

参考下图

![img](/assets/image/2023-07-17-mysql索引/页分裂.png)

![img](/assets/image/2023-07-17-mysql索引/开辟新页.png)

所以按照阿里的mysql建议。每个表的主键都应该是自增的。如果要用唯一主键，或者分布式ID，可以考虑使用独立的列。这样的好处是聚簇索引是高效的。而唯一ID可以使用hash索引走命中。一般来说唯一值也没有范围查询，最多有in查询。

### 索引最好设置为NOT NULL

1. 导致优化器难以工作
2. null没有意义的同时占用物理空间

## 索引失效

expain语句时，type有如下枚举值，**执行效率从低到高的顺序为**：

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）。

需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，**const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中**。

其他几个重要的参考指标：

- Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。

- Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。

- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。

  

B+树是按照索引值有序排列存储的，只能根据前缀进行比较。

* 左模糊或者全模糊会导致索引失效

* 对索引使用函数

* 使用表达式进行计算

* 对索引进行隐式类型转换

* 联合索引非最左匹配

  > 因为索引里面的节点存储的key对于联合索引是按照顺序进行存储的，所以不符合最左匹配原则。

  但是值得注意的是，因为有**查询优化器**，所以无所谓查询的时候字段在where语句里面的顺序

  比如(a, b, c)联合索引。可以匹配

* where a=1；

* where a=1 and b=2 and c=3；

* where  b=2 and c=3 and a=1 ；

* where a=1 and b=2；

不可以匹配

- where b=2；
- where c=3；
- where b=2 and c=3；

从 MySQL 5.6 之后，有一个**索引下推功能**，`where a = 1 and c = 3`就可以走索引。

explain时`Extra=Using index condition`表示用了索引下推。但是如果仅仅用第二列搜索，无法走索引。

### OR语句

在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

or的每个字段都需要建立索引，否则还是会触发全表。

## 不需要索引

1. where条件，group by用不到的字段
2. 字段内容是枚举值，也就是大量的重复数据
3. 表数据太少
4. 经常更新的字段

## 单表数据量

mysql的数据以页的形式存储，每页16k，而2000万数据是B+树3级的一个临界值。如果超过了这个数值，那么树会变更高，而且页也需要加载更多页，导致更多的IO从而导致效率极速下降。

我觉得单表500万+就应该考虑分库分表了。

## count(*)

在mysql中count(*)和count(1)性能是一样的。

实际上count(\*)是SQL中的，而count(1)是一种方言，更推荐count(\*)。